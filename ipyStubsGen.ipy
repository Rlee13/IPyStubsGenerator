import clr, sys, os

import sg_settings as SG
from sg_settings import *

clr.AddReference("System.Core")
import System

######## CHANGE TO ARGS
ASSEMBLY_NAME = "Eto"
########

sys.path.append(os.getcwd() + SG.ASSEMBLIES_PATH)

if (not clr.IsNetCoreApp):
    print(SG.dotnet_platform)
    sys.exit()
    
try:
    clr.AddReference(ASSEMBLY_NAME)
except Exception as e:
    print(SG.dependencies)
    print("\t\t\t" + ASSEMBLY_NAME, "from ", SG.ASSEMBLIES_PATH + "/" + ASSEMBLY_NAME + ".dll")
    sys.exit()

assembly_name = ASSEMBLY_NAME
assembly = None # 'Eto, Version=2.7.0.0, Culture=neutral, PublicKeyToken=null'
asm_module = None # 'Eto.dll'
nr_asm_clases = 0
asm_namespaces = set()
current_initpy = None

# common_asm = ["System", "Microsoft", "IronPython", "netstandard", "Mono", "ipy", "Snippets.scripting"]
common_asm = ["System"]

for i in clr.References:
    if i.GetName().Name == assembly_name:
        assembly = i # Eto, Version=2.7.0.0, Culture=neutral, PublicKeyToken=null
        _x = assembly.GetModules()
        for j in _x:
            if not j.ToString().startswith(tuple(common_asm)):
                asm_module = j
                break
        # print(asm_module.FullyQualifiedName) # -> Eto.dll
        # print(dir(asm_module)) # -> Eto.dll
        for _cls in asm_module.GetTypes():
            if (not _cls.IsClass) or (not _cls.IsPublic):
                continue

            print(_cls.Name)

            if _cls.Namespace.startswith(assembly_name):
                ns = _cls.FullName.rsplit('.', 1)[0]
                print(f"[INFO:] Process namespace: {ns}")
                asm_namespaces.add(ns)
                lines = []

                # Create underlying folder(s) and file(s)
                current_initfile_path = os.getcwd() + STUBS_PATH + "\\" + ns.replace('.', "\\") + "\\__init__.py"
                if not System.IO.File.Exists(current_initfile_path):
                    try:
                        System.IO.Directory.CreateDirectory(os.getcwd() + STUBS_PATH + "\\" + ns.replace('.', "\\"))
                        current_initfile_path = os.getcwd() + STUBS_PATH + "\\" + ns.replace('.', "\\") + "\\__init__.py"
                        current_initpy = System.IO.File.Create(current_initfile_path)
                        current_initpy.Close()
                    except Exception as e:
                        print("[IO ERROR:]", e)
                        sys.exit()
                
                # print(dir(_cls))
                # print(_cls.Name)
                # print(_cls.IsClass, _cls.IsPublic)
                # sys.exit()

                # ignore if it is compiler generated
                _compgen = False
                for _p in _cls.GetProperties():               
                    _attr = _p.GetCustomAttributes(True)
                    for _a in _attr:
                        if type(_a) is type(System.Runtime.CompilerServices.CompilerGeneratedAttribute):
                            _compgen = True
                            break
                if _compgen:
                    continue

                try:
                    _ret = _cls.BaseType.ToString().replace('.', "").replace('`', '_').replace('[', '_').replace(']', '_') if _cls.BaseType is not None else ""
                except Exception as e:
                    print(f"[ERROR]: {e}")
                    sys.exit()

                line = class_template.substitute(class_name = _cls.Name, 
                                    class_body = 'pass',
                                    class_base_type = _ret).strip()
                # print(line)
                lines.append(line)
                nr_asm_clases += 1
                
                try: 
                    # print(dir(current_initpy))
                    System.IO.File.AppendAllLines(current_initfile_path, lines)
                    current_initpy.Close()
                except Exception as e:
                    exc_type, exc_obj, exc_tb = sys.exc_info()
                    print("[IO ERROR:]", exc_tb.tb_lineno, e)
                    sys.exit()

print(f"\nProcessed {len(asm_namespaces)} namespaces, {nr_asm_clases} classes.")


